from __future__ import annotations

import os
import subprocess
from configparser import ConfigParser
from pathlib import Path
from string import Template

import yaml
from returns.maybe import Maybe, Nothing, Some
from returns.result import Failure, Result, Success, safe


def tmux_print(message):
    subprocess.Popen(
        ["tmux", "display-message", message],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def get_conf_path() -> Maybe[Path]:
    """
    Return the path to the config file.

    The result is a `Maybe` container containing a path to an
    existing config file.
    """
    fp: Path
    for base in ["~/.tmux_macros.conf", "~/.tmux/tmux_macros.conf"]:
        fp = Path(base).expanduser()
        if fp.exists():
            return Some(fp)

    return Nothing


def load_conf() -> Result[dict[str, str], str]:
    # Default plugin config path
    plugin_default_conf_path = Path(__file__).parent / "tmux_macros.conf"
    if not plugin_default_conf_path.exists():
        return Failure(f"{plugin_default_conf_path} does not exist")

    # Get config path: it's either one of the paths in get_conf_path
    # or plugin_default_conf_path
    conf_path = get_conf_path().value_or(plugin_default_conf_path)

    config = ConfigParser()

    # Use fake section header to parse ini-like key=value files
    try:
        with conf_path.open() as f:
            content = f"[default]\n{f.read()}"
            config.read_string(content)
    except OSError as e:
        return Failure(f"failed to open '{conf_path}' with error: {e}")

    raw_conf = dict(config.items("default"))

    def expand_vars(value: str, mapping: dict):
        value = Template(value).safe_substitute(mapping)
        return os.path.abspath(os.path.expanduser(value))

    # Expand and normalize all paths
    return Success({key: expand_vars(val, raw_conf) for key, val in raw_conf.items()})


def _generate_macros_cache(cache_path, macros_dict):
    with open(cache_path, "w") as f:
        f.write("MACROS = ")
        f.write(repr(macros_dict))


def _generate_tmux_conf(tmux_conf_file, macros, macros_py):
    with open(tmux_conf_file, "w") as f:
        f.write("# Auto-generated by tmux-macros\n\n")
        for name, val in macros.items():
            key = None
            if isinstance(val, dict) and "key" in val:
                key = val["key"]
            if key:
                f.write(f'bind-key -n {key} run-shell "python3 {macros_py} {name}"\n')


def resolve_macros(raw_macros):
    resolved = {}

    reusable = {k: v for k, v in raw_macros.items() if k != "macros"}
    macro_definitions = raw_macros.get("macros", {})

    def expand(commands):
        result = []
        for cmd in commands:
            if isinstance(cmd, list):
                for sub in cmd:
                    result.extend(expand([sub]))
            elif isinstance(cmd, dict) and "type" in cmd:
                result.append(cmd)
            elif isinstance(cmd, str) and cmd in reusable:
                result.extend(expand(reusable[cmd]))
            else:
                result.append(cmd)
        return result

    for name, value in macro_definitions.items():
        if isinstance(value, dict) and "commands" in value:
            resolved[name] = {
                "commands": expand(value["commands"]),
                "key": value.get("key", None),
            }
        else:
            resolved[name] = expand(value)

    return resolved


def parse_macros_yml_and_generate_cache(conf):
    yml_file = conf["macros_yml"]
    cache_file = conf["macros_cache_py"]
    tmux_conf_file = conf["tmux_macros_conf"]
    macros_py = conf["macros_py"]

    if not os.path.exists(yml_file):
        raise FileNotFoundError(f"macros.yml not found at: {yml_file}")

    with open(yml_file, "r") as f:
        raw_macros = yaml.safe_load(f)

    resolved_macros = resolve_macros(raw_macros)

    _generate_macros_cache(cache_file, resolved_macros)
    _generate_tmux_conf(tmux_conf_file, resolved_macros, macros_py)
    tmux_print("âœ… Cache and tmux config generated successfully.")
