from __future__ import annotations

import os
import subprocess
from configparser import ConfigParser
from pathlib import Path
from string import Template
from typing import TYPE_CHECKING, overload

import yaml
from returns.maybe import Maybe, Nothing, Some
from returns.result import Failure, Result, Success, safe  # noqa: F401

if TYPE_CHECKING:
    from typing import Any, Type, TypeGuard


def tmux_print(message):
    subprocess.Popen(
        ["tmux", "display-message", message],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def get_conf_path() -> Maybe[Path]:
    """
    Return the path to the config file.

    The result is a `Maybe` container containing a path to an
    existing config file.
    """
    fp: Path
    for base in ["~/.tmux_macros.conf", "~/.tmux/tmux_macros.conf"]:
        fp = Path(base).expanduser()
        if fp.exists():
            return Some(fp)

    return Nothing


def load_conf(
    config_file: Maybe[Path]=Nothing,
    plugin_dir: Maybe[Path]=Nothing
) -> Result[dict[str, str], str]:
    # Default plugin config path
    plugin_default_conf_path = config_file.value_or(
        Path(__file__).parent / "tmux_macros.conf"
    )
    if not plugin_default_conf_path.exists():
        return Failure(f"{plugin_default_conf_path} does not exist")

    # Get config path: it's either one of the paths in get_conf_path
    # or plugin_default_conf_path
    conf_path = get_conf_path().value_or(plugin_default_conf_path)

    config = ConfigParser()

    # Use fake section header to parse ini-like key=value files
    try:
        with conf_path.open() as f:
            content = f"[default]\n{f.read()}"
            config.read_string(content)
    except OSError as e:
        return Failure(f"failed to open '{conf_path}' with error: {e}")

    raw_conf = dict(config.items("default"))

    match plugin_dir:
        case Some(d):
            raw_conf["plugin_dir"] = str(d)

        case Nothing:  # noqa: F841
            pass      # Do nothing

    def expand_vars(value: str, mapping: dict):
        value = Template(value).safe_substitute(mapping)
        return os.path.abspath(os.path.expanduser(value))

    # Expand and normalize all paths
    return Success({key: expand_vars(val, raw_conf) for key, val in raw_conf.items()})


@safe
def _generate_macros_cache(cache_path: Path, macros_dict: dict[str, Any]):
    import pickle

    with cache_path.open("wb") as fd:
        pickle.dump(macros_dict, fd)


@safe
def _generate_tmux_conf(tmux_conf_file: Path, macros: dict[str, Any], macros_py: Path):
    with open(tmux_conf_file, "w") as fd:
        print("# Auto-generated by tmux-macros", end="\n\n", file=fd)

        for name, val in macros.items():
            key = None
            if is_what(val, dict, dict[str, "Any"]) and "key" in val:
                if (key := val["key"]):
                    # TODO: change to RUN_SH NAME
                    print(f"bind-key -n {key} run-shell \"python3 {macros_py} {name}\"", file=fd)


@overload
def is_what[T](obj: Any, dtype: Type[T]) -> TypeGuard[T]: ...


@overload
def is_what[T](obj: Any, dtype: type, _stype: Type[T]) -> TypeGuard[T]: ...


def is_what(obj, dtype, _stype=None):
    """
    Assert that OBJ is of type DTYPE.

    This function mainly serves the purpose of static type
    checking: _STYPE is what the type checker considers to be
    the actual type of OBJ, and DTYPE is what Python checks at
    runtime.
    """
    return isinstance(obj, dtype)


def resolve_macros(raw_macros: dict[str, Any]) -> Result[dict[str, Any], str]:
    resolved = {}

    # Capture the reusable commands
    reusable: dict[str, Any] = {k: v for k, v in raw_macros.items() if k != "macros"}

    # Capture macro definitions
    macro_definitions: dict[str, Any] = raw_macros.get("macros", {})

    def expand(commands) -> list[Any]:  # TODO: narrow this type
        result = []

        for cmd in commands:
            if isinstance(cmd, list):
                # List of commands
                for sub in cmd:
                    result.extend(expand([sub]))
            elif isinstance(cmd, dict) and "type" in cmd:
                # Dictionary
                result.append(cmd)
            elif isinstance(cmd, str) and cmd in reusable:
                # References a reusable command
                result.extend(expand(reusable[cmd]))
            else:
                result.append(cmd)

        return result

    # name = None
    for name, value in macro_definitions.items():
        try:
            if is_what(value, dict, dict[str, "Any"]) and "commands" in value:
                resolved[name] = {
                    "commands": expand(value["commands"]),
                    "key": value.get("key", None),
                }
            else:
                resolved[name] = expand(value)
        except KeyError as e:
            e.add_note(f"in macro command {name}")
            return Failure(f"missing key in macro definitions: {e}")

    return Success(resolved)


def parse_macros_yml_and_generate_cache(conf: dict[str, str]) -> Maybe[str]:
    # TODO: write docstring

    yml_file = Path(conf["macros_yml"])
    cache_file = Path(conf["macros_cache_py"])
    tmux_conf_file = Path(conf["tmux_macros_conf"])
    macros_py = Path(conf["macros_py"])

    # Error if file cannot be found
    if not yml_file.exists():
        return Some(f"macros.yml not found at: {yml_file}")

    # Try reading the file and return error if there is an exception
    try:
        with open(yml_file, "r") as f:
            raw_macros = yaml.safe_load(f)
    except OSError as e:
        return Some(f"could not open {yml_file}: {e}")
    except yaml.YAMLError as e:
        return Some(f"YAML parsing error: {e}")

    # Ensure that the file is formatted correctly
    if not is_what(raw_macros, dict, dict[str, "Any"]):
        return Some(f"{yml_file} is not formatted correctly\n{raw_macros=!r}")

    # Try to resolve the macros
    resolved_macros = None
    match resolve_macros(raw_macros):
        case Success(s):
            resolved_macros = s

        case Failure(e):
            return Some(e)
    assert resolved_macros is not None

    # Try to generate the cache
    match _generate_macros_cache(cache_file, resolved_macros):
        case Failure(e):
            return Some(f"failed generating cache: {e}")

    # Try to generate the config
    match _generate_tmux_conf(tmux_conf_file, resolved_macros, macros_py):
        case Failure(e):
            return Some(f"failed generating config: {e}")

    tmux_print("✅️ Cache and tmux config generated successfully.")

    return Nothing
