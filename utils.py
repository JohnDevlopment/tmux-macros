from __future__ import annotations

import os
import subprocess
from configparser import ConfigParser

import yaml


def tmux_print(message):
    subprocess.Popen(
        ["tmux", "display-message", message],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def load_conf():
    user_conf_path = os.path.expanduser("~/.tmux_macros.conf")
    plugin_default_conf_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "tmux_macros.conf"
    )

    conf_path = (
        user_conf_path if os.path.exists(user_conf_path) else plugin_default_conf_path
    )

    config = ConfigParser()
    # Use fake section header to parse ini-like key=value files
    with open(conf_path) as f:
        content = f"[default]\n" + f.read()
        config.read_string(content)

    raw_conf = dict(config.items("default"))

    # Add plugin_dir variable manually for substitution
    plugin_dir = os.path.dirname(os.path.abspath(__file__))

    def expand_vars(value):
        value = value.replace("${plugin_dir}", plugin_dir)
        return os.path.abspath(os.path.expanduser(value))

    # Expand and normalize all paths
    expanded_conf = {key: expand_vars(val) for key, val in raw_conf.items()}

    return expanded_conf


def _generate_macros_cache(cache_path, macros_dict):
    with open(cache_path, "w") as f:
        f.write("MACROS = ")
        f.write(repr(macros_dict))


def _generate_tmux_conf(tmux_conf_file, macros, macros_py):
    with open(tmux_conf_file, "w") as f:
        f.write("# Auto-generated by tmux-macros\n\n")
        for name, val in macros.items():
            key = None
            if isinstance(val, dict) and "key" in val:
                key = val["key"]
            if key:
                f.write(f'bind-key -n {key} run-shell "python3 {macros_py} {name}"\n')


def resolve_macros(raw_macros):
    resolved = {}

    reusable = {k: v for k, v in raw_macros.items() if k != "macros"}
    macro_definitions = raw_macros.get("macros", {})

    def expand(commands):
        result = []
        for cmd in commands:
            if isinstance(cmd, list):
                for sub in cmd:
                    result.extend(expand([sub]))
            elif isinstance(cmd, dict) and "type" in cmd:
                result.append(cmd)
            elif isinstance(cmd, str) and cmd in reusable:
                result.extend(expand(reusable[cmd]))
            else:
                result.append(cmd)
        return result

    for name, value in macro_definitions.items():
        if isinstance(value, dict) and "commands" in value:
            resolved[name] = {
                "commands": expand(value["commands"]),
                "key": value.get("key", None),
            }
        else:
            resolved[name] = expand(value)

    return resolved


def parse_macros_yml_and_generate_cache(conf):
    yml_file = conf["macros_yml"]
    cache_file = conf["macros_cache_py"]
    tmux_conf_file = conf["tmux_macros_conf"]
    macros_py = conf["macros_py"]

    if not os.path.exists(yml_file):
        raise FileNotFoundError(f"macros.yml not found at: {yml_file}")

    with open(yml_file, "r") as f:
        raw_macros = yaml.safe_load(f)

    resolved_macros = resolve_macros(raw_macros)

    _generate_macros_cache(cache_file, resolved_macros)
    _generate_tmux_conf(tmux_conf_file, resolved_macros, macros_py)
    tmux_print("âœ… Cache and tmux config generated successfully.")
